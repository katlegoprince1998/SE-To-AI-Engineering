## High-Level Architecture

High-level architecture describes how major components of a system are structured,
how they communicate, and how responsibilities are divided.

It focuses on:
- Components
- Communication
- Data flow
- Scalability and reliability decisions

---

## Client–Server Model

### What it is
A distributed architecture where:
- **Client** requests services or data
- **Server** processes requests and returns responses

### Components
- Client: Browser, Mobile App, Desktop App
- Server: Backend application
- Network: HTTP/HTTPS over the internet or internal network

### How it works
1. Client sends a request
2. Server processes the request
3. Server sends a response
4. Client renders or uses the response

### Why it is used
- Separation of concerns
- Centralized data and logic
- Easier updates and maintenance

### When to use
- Web applications
- Mobile applications
- APIs and services

### Pros
- Centralized control
- Easier security management
- Reusable backend logic

### Cons
- Server can be a bottleneck
- Network dependency
- Scalability requires planning

---

## Monolith vs Microservices

### Monolithic Architecture

#### What it is
A single, unified application where:
- UI
- Business logic
- Data access
are tightly coupled and deployed together

#### Characteristics
- Single codebase
- Single deployment unit
- Shared database

#### Pros
- Simple to build and deploy
- Easier debugging
- Lower operational complexity

#### Cons
- Hard to scale specific features
- Slower deployments as system grows
- One failure can affect entire system

#### When to use
- Small to medium applications
- Early-stage startups
- Simple business domains

---

### Microservices Architecture

#### What it is
A system composed of **independent services**, each responsible for a single business capability.

#### Characteristics
- Each service has its own codebase
- Independent deployments
- Often owns its own database
- Communicates via HTTP or messaging

#### Pros
- Independent scaling
- Faster team velocity
- Fault isolation
- Technology flexibility

#### Cons
- High operational complexity
- Network latency
- Data consistency challenges
- Requires DevOps maturity

#### When to use
- Large-scale systems
- Multiple teams
- Complex business domains
- High scalability requirements

---

### Monolith vs Microservices Comparison

| Aspect          | Monolith           | Microservices         |
|-----------------|--------------------|-----------------------|
| Deployment      | Single unit        | Multiple services     |
| Scaling         | Entire app         | Per service           |
| Complexity      | Low                | High                  |
| Failure impact  | High               | Isolated              |
| Best for        | Small systems      | Large systems         |

---

## 2-Tier vs 3-Tier Architecture

### 2-Tier Architecture

#### What it is
The system is divided into:
1. Client
2. Server (business logic + database)

#### Structure
- Client ↔ Server

#### Pros
- Simple design
- Low latency
- Easy to implement

#### Cons
- Poor scalability
- Tight coupling
- Limited security layers

#### When to use
- Small internal applications
- Desktop applications
- Simple client-server systems

---

### 3-Tier Architecture

#### What it is
The system is divided into:
1. Presentation layer (UI)
2. Application layer (business logic)
3. Data layer (database)

#### Structure
- Client ↔ Application Server ↔ Database

#### Pros
- Better separation of concerns
- Improved scalability
- Enhanced security
- Easier maintenance

#### Cons
- More complexity
- Slightly higher latency

#### When to use
- Web applications
- Enterprise systems
- Scalable platforms

---

### 2-Tier vs 3-Tier Comparison

| Aspect        | 2-Tier           | 3-Tier             |
|---------------|------------------|--------------------|
| Layers        | 2                | 3                  |
| Scalability   | Limited          | High               |
| Security      | Basic            | Stronger           |
| Maintenance   | Harder           | Easier             |

---

## Request–Response Lifecycle

### What it is
The complete journey of a request from the client to the server and back.

---

### Step-by-Step Lifecycle

1. Client initiates a request  
   - User clicks a button or loads a page

2. DNS resolution  
   - Domain name is resolved to an IP address

3. Network connection  
   - TCP handshake and TLS negotiation (HTTPS)

4. Request reaches server  
   - Load balancer routes the request
   - Web server accepts the connection

5. Application processing  
   - Authentication & authorization
   - Business logic execution
   - Database queries

6. Response generation  
   - Server formats response (JSON, HTML)

7. Response sent back  
   - Over the network to the client

8. Client rendering  
   - UI updates or data is displayed

---

### Why it matters
- Performance optimization
- Debugging latency issues
- Security enforcement
- Scalability planning

---

### When to optimize the lifecycle
- High latency
- High traffic
- Frequent timeouts
- User experience issues

---

### Common Optimization Points
- Caching
- Load balancing
- Database indexing
- Async processing
- CDN usage

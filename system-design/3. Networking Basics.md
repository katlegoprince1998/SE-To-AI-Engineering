## Networking Basics (Must Know)

Networking fundamentals explain how systems communicate, exchange data,
and scale reliably over the internet.

---

## HTTP vs HTTPS

### HTTP (HyperText Transfer Protocol)

#### What it is
A stateless application-layer protocol used for communication between
clients and servers.

#### Characteristics
- Plain text communication
- No encryption
- Uses TCP (port 80)

#### Risks
- Data can be intercepted
- Vulnerable to man-in-the-middle attacks
- No data integrity or authentication

#### When HTTP is used
- Local development
- Internal services in trusted networks
- Non-sensitive data transfer

---

### HTTPS (HTTP Secure)

#### What it is
HTTP over TLS/SSL, providing encrypted communication.

#### Characteristics
- Encrypted data
- Server authentication via certificates
- Data integrity
- Uses TCP (port 443)

#### How HTTPS works (simplified)
1. Client requests secure connection
2. Server sends SSL certificate
3. Client verifies certificate
4. Encryption keys are exchanged
5. Secure communication begins

#### Why HTTPS is important
- Protects sensitive data
- Prevents data tampering
- Required for modern browsers and SEO

---

### HTTP vs HTTPS Comparison

| Aspect          | HTTP            | HTTPS               |
|-----------------|-----------------|---------------------|
| Encryption      | No              | Yes                 |
| Security        | Low             | High                |
| Port            | 80              | 443                 |
| Use case        | Internal/dev    | Production systems  |

---

## REST vs GraphQL

### REST (Representational State Transfer)

#### What it is
An architectural style based on resources and standard HTTP methods.

#### Core principles
- Stateless
- Resource-based URLs
- Uses HTTP verbs

#### Common HTTP methods
- GET: Read data
- POST: Create data
- PUT/PATCH: Update data
- DELETE: Remove data

#### Example


#### Pros
- Simple and widely adopted
- Easy caching
- Works well with HTTP infrastructure

#### Cons
- Over-fetching or under-fetching data
- Multiple requests for related data

---

### GraphQL

#### What it is
A query language for APIs that allows clients to request exactly the data they need.

#### How it works
- Single endpoint
- Client defines data structure
- Server resolves requested fields

#### Example



#### Pros
- No over-fetching
- Flexible queries
- Efficient for complex UIs

#### Cons
- Complex caching
- Higher server complexity
- Learning curve

---

### REST vs GraphQL Comparison

| Aspect            | REST                 | GraphQL              |
|-------------------|----------------------|----------------------|
| Endpoints         | Multiple             | Single               |
| Data fetching     | Fixed responses      | Client-defined       |
| Caching           | Easy                 | Complex              |
| Best for          | Simple APIs          | Complex frontends    |

---

## TCP vs UDP

### TCP (Transmission Control Protocol)

#### What it is
A reliable, connection-oriented transport protocol.

#### Characteristics
- Guarantees delivery
- Ordered packets
- Error checking and retransmission
- Congestion control

#### How TCP works
1. Three-way handshake
2. Data transmission
3. Acknowledgements
4. Connection termination

#### When to use TCP
- Web applications
- File transfers
- Emails
- Financial systems

---

### UDP (User Datagram Protocol)

#### What it is
A fast, connectionless transport protocol.

#### Characteristics
- No delivery guarantee
- No ordering
- Low latency
- Minimal overhead

#### When to use UDP
- Video streaming
- Online gaming
- Voice calls
- Real-time analytics

---

### TCP vs UDP Comparison

| Aspect        | TCP              | UDP              |
|---------------|------------------|------------------|
| Reliability   | Guaranteed       | Best effort      |
| Speed         | Slower           | Faster           |
| Ordering      | Yes              | No               |
| Use case      | Data integrity   | Real-time data   |

---

## DNS (How google.com becomes an IP)

### What DNS is
Domain Name System translates human-readable domain names into IP addresses.

---

### DNS Resolution Steps

1. User enters `google.com`
2. Browser checks local cache
3. OS checks DNS cache
4. Request sent to recursive DNS resolver
5. Resolver queries:
   - Root DNS server
   - TLD server (.com)
   - Authoritative DNS server
6. IP address returned
7. Browser connects to the IP

---

### Why DNS matters
- Enables human-friendly URLs
- Improves performance via caching
- Critical for availability

---

## Load Balancer Basics

### What is a Load Balancer
A component that distributes incoming traffic across multiple servers.

---

### Why Load Balancers are used
- Prevent server overload
- Improve availability
- Increase scalability
- Enable fault tolerance

---

### How Load Balancers work
1. Client sends request
2. Load balancer receives request
3. Chooses backend server
4. Forwards request
5. Returns response to client

---

### Load Balancing Strategies
- Round Robin
- Least Connections
- IP Hash
- Weighted distribution

---

### Types of Load Balancers

#### Layer 4 (Transport Layer)
- Routes traffic based on IP and port
- Faster, less intelligent

#### Layer 7 (Application Layer)
- Routes based on headers, paths, cookies
- Supports SSL termination and routing rules

---

### When to use Load Balancers
- High traffic systems
- Horizontal scaling
- High availability requirements
- Microservices architectures

